#ifndef SIMPLEDB_BTREE_SRC_BTREE_HPP_
#define SIMPLEDB_BTREE_SRC_BTREE_HPP_

#include <array>
#include <vector>
#include <memory>
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>

using std::array;
using std::fill;
using std::function;
using std::ios;
using std::shared_ptr;

template <class T>
class Property
{
protected:
    T value;

public:
    Property() {}
    explicit Property(const T &f) { value = f; }
    virtual ~Property() {}

    virtual auto operator=(const T &f) -> T & { return value = f; }
    virtual auto operator()() const -> const T & { return value; }
    virtual auto itself() -> T & { return value; }
};

template <class T, int S>
class ArrayProperty
{
protected:
    array<T, S> value;

public:
    ArrayProperty() {}
    explicit ArrayProperty(const T &f) { value.fill(f); }
    explicit ArrayProperty(const array<T, S> &f) { value = f; }
    virtual ~ArrayProperty() {}

    virtual auto operator[](int i) -> T & { return value[i]; }
    virtual auto operator()() const -> const array<T, S> & { return value; }
    virtual auto itself() -> array<T, S> & { return value; }
    virtual void set(int i, const T &f) { value[i] = f; }
};

class Pager : protected std::fstream
{
public:
    explicit Pager(std::string file_name, bool trunc = false)
        : std::fstream(file_name.data(), ios::in | ios::out | ios::binary)
    {
        empty = false;
        fileName = file_name;
        if (!good() || trunc)
        {
            empty = true;
            open(file_name.data(),
                 ios::in | ios::out | ios::trunc | ios::binary);
        }
    }
    ~Pager() { close(); }
    inline bool is_empty() { return empty; }
    template <class Register>
    void save(const int64_t &n, Register *reg)
    {
        clear();
        //off: offset value
        //way: object of type ios_base::seekdir (begin current or end)
        seekp(n * sizeof(Register), std::ios::beg);
        //pointer to an array of at least n characters
        //reinterpret_cast convert any pointer object to char pointer
        //(work with bits)
        write(reinterpret_cast<char *>(reg), sizeof(*reg));
    }
    template <class Register>
    bool recover(const int64_t &n, Register *reg)
    {
        clear();
        seekg(n * sizeof(Register), std::ios::beg);
        read(reinterpret_cast<char *>(reg), sizeof(*reg));
        return gcount() > 0;
    }

    template <class Register>
    void erase(const int64_t &n)
    {
        clear();
        char mark = 'N';
        seekg(n * sizeof(Register), std::ios::beg);
        write(&mark, 1);
    }

private:
    std::string fileName;
    bool empty;
    int64_t page_id_count;
};

template <class T, int ORDER>
class Node
{
public:
    Property<int64_t> page_id{-1};
    Property<int64_t> count{0};
    Property<int64_t> right{0};
    ArrayProperty<T, ORDER + 1> data{};
    ArrayProperty<int64_t, ORDER + 2> children{0};

public:
    Node()
    {
        this->page_id = 0;
        this->count = 0;
        this->right = 0;
    }
    explicit Node(int64_t page_id)
    {
        this->page_id = page_id;
        this->count = 0;
        this->right = 0;
    }

    void insert_in_node(int64_t pos, const T &value)
    {
        auto j = count();
        while (j > pos)
        {
            data[j] = data[j - 1];
            children[j + 1] = children[j];
            j--;
        }
        data[j] = value;
        children[j + 1] = children[j];
        count = count() + 1;
    }
    void delete_in_node(int64_t pos)
    {
        for (auto i = pos; i < count; i++)
        {
            data[i] = data[i + 1];
            children[i + 1] = children[i + 2];
        }
        count--;
    }
    bool is_overflow() const { return count() > ORDER; }
    bool is_underflow() const { return count() < floor(ORDER / 2.0); }
};

template <class T, int B>
class Iterator
{
public:
    using node = Node<T, B>;
    //int64_t index = 0;
    Property<int64_t> index{0};
    Property<node> current_pos;
    //node current_pos;
    shared_ptr<Pager> pm;

public:
    Iterator() {}
    Iterator(const Iterator &that) // FIXME: explicit
    {
        this->current_pos = that.current_pos();
        this->index = that.index();
        this->pm = that.pm;
    }
    explicit Iterator(shared_ptr<Pager> pm) : pm{pm} {}
    auto operator*() -> T
    {
        return current_pos.itself().data()[index()];
    }
    auto operator++() -> Iterator &
    {
        if (index() < current_pos().count() - 1)
        {
            index = index() + 1;
        }
        else
        {
            index = 0;
            node that(-1);
            if (current_pos().right() == 0)
            {
                current_pos = that;
            }
            else
            {
                this->pm->recover(current_pos().right(), &current_pos.itself());
            }
        }
        return *this;
    }
    auto operator=(const Iterator &that) -> Iterator &
    {
        this->current_pos = that.current_pos();
        this->index = that.index();
        this->pm = that.pm;
        return *this;
    }
    bool operator!=(const Iterator &that) const
    {
        if (this->current_pos().page_id() == that.current_pos().page_id())
        {
            auto this_n = this->current_pos();
            auto that_n = that.current_pos();
            return !(this_n.data()[index()] == that_n.data()[that.index()]);
        }
        return true;
    }
};

template <class T, int ORDER = 3>
class btree
{
private:
    using node = Node<T, ORDER>;
    using iterator = Iterator<T, ORDER>;
    shared_ptr<Pager> pm;
    struct Header
    {
        int64_t root_id = 1;
        int64_t count = 0;
    };
    shared_ptr<Header> header = std::make_shared<Header>();
    enum class btree_state
    {
        BT_OVERFLOW, // TODO:
        BT_UNDERFLOW,
        OK,
    };

public:
    auto begin() -> iterator
    {
        auto root = read_node(header->root_id);
        while (root.children()[0] != 0)
        {
            auto id = root.children()[0];
            root = read_node(id);
        }
        iterator it(pm);
        it.current_pos = root;
        return it;
    }
    auto find(const T &value) -> iterator
    {
        function<iterator(const T &, const node &)>
            find_helper = [&](const T &value, const node &root) -> iterator {
            auto pos = 0;
            if (root.children()[0] != 0)
            {
                while (pos < root.count() && root.data()[pos] <= value)
                {
                    pos++;
                }
                auto child = read_node(root.children()[pos]);
                return find_helper(value, child);
            }
            else
            {
                while (pos < root.count() && root.data()[pos] < value)
                {
                    pos++;
                }
                iterator it(pm);
                it.current_pos = root;
                it.index = pos;
                return it;
            }
        };
        auto root = read_node(header->root_id);
        auto it = find_helper(value, root);
        return *it == value ? it : end();
    }
    auto end() -> iterator
    {
        node end(-1);
        iterator it(pm);
        it.current_pos = end;
        return it;
    }
    explicit btree(shared_ptr<Pager> pm)
    {
        this->pm = pm;
        if (pm->is_empty())
        {
            node root(header->root_id);
            pm->save(root.page_id(), &root);
            header->count++;
            pm->save(0, header.get());
        }
        else
        {
            pm->recover(0, header.get());
        }
    }
    void write_node(int64_t id, node n_ptr)
    {
        pm->save(id, &n_ptr);
    }
    auto read_node(int64_t id) -> node
    {
        node ret(-1);
        pm->recover(id, &ret);
        return ret;
    }
    auto new_node() -> node
    {
        header->count++;
        node ret(header->count);
        pm->save(0, header.get());
        return ret;
    }
    void insert(const T &value)
    {
        auto root = read_node(header->root_id);
        auto state = insert(&root, value);
        if (state == btree_state::BT_OVERFLOW)
        {
            auto node_in_overflow = read_node(header->root_id);
            auto child1 = new_node();
            auto child2 = new_node();

            auto pos = 0;
            auto iter = 0;
            auto i = 0;
            for (i = 0; iter < ceil(ORDER / 2.0); i++)
            {
                child1.children.set(i, node_in_overflow.children()[iter]);
                child1.data.set(i, node_in_overflow.data()[iter]);
                child1.count = child1.count() + 1; // FIXME:
                iter++;
            }
            child1.children.set(i, node_in_overflow.children()[iter]);

            node_in_overflow.data.set(0, node_in_overflow.data()[iter]);
            child1.right = child2.page_id();

            if (node_in_overflow.children()[0] != 0)
            {
                iter++;
            }

            for (i = 0; iter < ORDER + 1; i++)
            {
                child2.children.set(i, node_in_overflow.children()[iter]);
                child2.data.set(i, node_in_overflow.data()[iter]);
                child2.count = child2.count() + 1; // FIXME:
                iter++;
            }
            child2.children.set(i, node_in_overflow.children()[iter]);

            node_in_overflow.children.set(0, child1.page_id());
            node_in_overflow.children.set(1, child2.page_id());
            node_in_overflow.count = 1;

            write_node(node_in_overflow.page_id(), node_in_overflow);
            write_node(child1.page_id(), child1);
            write_node(child2.page_id(), child2);
        }
    }
    auto insert(node *n, const T &value) -> btree_state
    {
        auto pos = 0;
        while (pos < n->count() && n->data()[pos] < value)
        {
            pos++;
        }
        if (n->children()[pos] != 0)
        {
            auto id = n->children()[pos];
            auto child = read_node(id);
            auto state = insert(&child, value);
            if (state == btree_state::BT_OVERFLOW)
            {
                auto node_in_overflow = read_node(n->children()[pos]);
                auto child1 = node_in_overflow;
                child1.count = 0;
                auto child2 = new_node();

                auto iter = 0;
                auto i = 0;
                for (i = 0; iter < ceil(ORDER / 2.0); i++)
                {
                    child1.children.set(i, node_in_overflow.children()[iter]);
                    child1.data.set(i, node_in_overflow.data()[iter]);
                    child1.count = child1.count() + 1; // FIXME:
                    iter++;
                }
                child1.children.set(i, node_in_overflow.children()[iter]);

                n->insert_in_node(pos, node_in_overflow.data()[iter]);
                if (node_in_overflow.children()[0] != 0)
                {
                    iter++;
                }
                else
                {
                    child2.right = child1.right();
                    child1.right = child2.page_id();
                    n->children.set(pos + 1, child2.page_id());
                }
                for (i = 0; iter < ORDER + 1; i++)
                {
                    child2.children.set(i, node_in_overflow.children()[iter]);
                    child2.data.set(i, node_in_overflow.data()[iter]);
                    child2.count = child2.count() + 1; // FIXME:
                    iter++;
                }
                child2.children.set(i, node_in_overflow.children()[iter]);
                n->children.set(pos, child1.page_id());
                n->children.set(pos + 1, child2.page_id());
                write_node(n->page_id(), *n);
                write_node(child1.page_id(), child1);
                write_node(child2.page_id(), child2);
            }
        }
        else
        {
            n->insert_in_node(pos, value);
            write_node(n->page_id(), *n);
        }
        return n->is_overflow() ? btree_state::BT_OVERFLOW : btree_state::OK;
    }
};

#endif //SIMPLEDB_BTREE_SRC_BTREE_HPP_
